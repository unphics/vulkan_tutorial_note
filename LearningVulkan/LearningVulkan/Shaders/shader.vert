
/*顶点着色器除了每个传入的顶点。将其属性(如世界位置、颜色、法线和纹理坐标)作为输入。输出的是剪辑坐标中的最终位置以及需要传递给片段着色器的属性如颜色和纹理坐标。然后这些值将由光栅化器在片段上进行插值以产生平滑的渐变
裁切坐标是来自顶点着色器的四维向量，随后通过将整个向量除以其最后一个分量将其转换为标准化的设备坐标。这些标准化的设备坐标是齐次坐标，将帧缓冲区映射到[-1,1]x[-1,1]坐标系。就是从左上角为0点右下1920*1080转换为中间是0点左上-1右下1*/

/*对于第一个三角形，我们不会应用任何变换，只需要将三个顶点的位置直接指定为标准化设备坐标，以创建三角形形状
我们可以直接输出归一化的设备坐标，方法是将他们作为裁剪坐标从顶点着色器输出，最后一个分量设为1,。这样讲裁切坐标转换为标准设备坐标的划分不会改变任何内容
通常这些坐标将存储在顶点缓冲区中，但在vk中创建2顶点缓冲区并非易事。因此，教程将其推迟到第一个三角形之后。
与此同时，我们将做一些非正统的事情：将坐标直接包含在顶点着色器中*/

//vk版本号
#version 450
layout(location = 0) out vec3 fragColor;
vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
//main为每个顶点调用该函数。内置gl_VertexIndex变量包含当前顶点的索引。这通常是顶点缓冲区的索引
//每个顶点的位置从做事情中的常量数值访问，并与虚拟z和w分量组合以产生裁切坐标中的位置。内置变量gl_Position用作输出